#!/usr/bin/env python
"""
Standalone Reachy Mini TTS + Head Wobble Mimic
----------------------------------------------
Place this file anywhere and execute as a CLI tool.
"""

import os
import sys
import time
import math
import wave
import threading
import argparse
from typing import Any, Dict, List, Optional
from collections import deque
from itertools import islice

import pyaudio
import numpy as np
from numpy.typing import NDArray

from openai import OpenAI
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn

from reachy_mini import ReachyMini
from reachy_mini.utils import create_head_pose
from reachy_mini.utils.interpolation import compose_world_offset

SR = 16_000
FRAME_MS = 20
HOP_MS = 50

SWAY_MASTER = 1.5
SENS_DB_OFFSET = +4.0
VAD_DB_ON = -35.0
VAD_DB_OFF = -45.0
VAD_ATTACK_MS = 40
VAD_RELEASE_MS = 250
ENV_FOLLOW_GAIN = 0.65

SWAY_F_PITCH, SWAY_A_PITCH_DEG = 2.2, 4.5
SWAY_F_YAW, SWAY_A_YAW_DEG = 0.6, 7.5
SWAY_F_ROLL, SWAY_A_ROLL_DEG = 1.3, 2.25
SWAY_F_X, SWAY_A_X_MM = 0.35, 4.5
SWAY_F_Y, SWAY_A_Y_MM = 0.45, 3.75
SWAY_F_Z, SWAY_A_Z_MM = 0.25, 2.25

SWAY_DB_LOW, SWAY_DB_HIGH = -46.0, -18.0
LOUDNESS_GAMMA = 0.9
SWAY_ATTACK_MS = 50
SWAY_RELEASE_MS = 250

FRAME = int(SR * FRAME_MS / 1000)
HOP = int(SR * HOP_MS / 1000)
ATTACK_FR = max(1, int(VAD_ATTACK_MS / HOP_MS))
RELEASE_FR = max(1, int(VAD_RELEASE_MS / HOP_MS))
SWAY_ATTACK_FR = max(1, int(SWAY_ATTACK_MS / HOP_MS))
SWAY_RELEASE_FR = max(1, int(SWAY_RELEASE_MS / HOP_MS))

def _rms_dbfs(x: NDArray[np.float32]) -> float:
    x = x.astype(np.float32, copy=False)
    rms = np.sqrt(np.mean(x * x, dtype=np.float32) + 1e-12, dtype=np.float32)
    return float(20.0 * math.log10(float(rms) + 1e-12))

def _loudness_gain(db: float, offset: float = SENS_DB_OFFSET) -> float:
    t = (db + offset - SWAY_DB_LOW) / (SWAY_DB_HIGH - SWAY_DB_LOW)
    t = max(0.0, min(1.0, t))
    return t**LOUDNESS_GAMMA if LOUDNESS_GAMMA != 1.0 else t

def _to_float32_mono(x: NDArray[Any]) -> NDArray[np.float32]:
    a = np.asarray(x)
    if a.ndim == 0: return np.zeros(0, dtype=np.float32)
    if a.ndim == 2:
        a = np.mean(a, axis=0) if a.shape[0] <= 8 and a.shape[0] <= a.shape[1] else np.mean(a, axis=1)
    elif a.ndim > 2:
        a = np.mean(a.reshape(a.shape[0], -1), axis=0)
    if np.issubdtype(a.dtype, np.floating):
        return a.astype(np.float32, copy=False)
    info = np.iinfo(a.dtype)
    scale = float(max(-info.min, info.max))
    return a.astype(np.float32) / (scale if scale != 0.0 else 1.0)

def _resample_linear(x: NDArray[np.float32], sr_in: int, sr_out: int) -> NDArray[np.float32]:
    if sr_in == sr_out or x.size == 0: return x
    n_out = int(round(x.size * sr_out / sr_in))
    if n_out <= 1: return np.zeros(0, dtype=np.float32)
    t_in = np.linspace(0.0, 1.0, num=x.size, dtype=np.float32, endpoint=True)
    t_out = np.linspace(0.0, 1.0, num=n_out, dtype=np.float32, endpoint=True)
    return np.interp(t_out, t_in, x).astype(np.float32, copy=False)

class SwayRollRT:
    def __init__(self, rng_seed: int = 7):
        self._seed = int(rng_seed)
        self.samples: deque[float] = deque(maxlen=10 * SR)
        self.carry = np.zeros(0, dtype=np.float32)
        self.vad_on = False
        self.vad_above = self.vad_below = 0
        self.sway_env = 0.0
        self.sway_up = self.sway_down = 0
        
        rng = np.random.default_rng(self._seed)
        self.phase_pitch = float(rng.random() * 2 * math.pi)
        self.phase_yaw = float(rng.random() * 2 * math.pi)
        self.phase_roll = float(rng.random() * 2 * math.pi)
        self.phase_x = float(rng.random() * 2 * math.pi)
        self.phase_y = float(rng.random() * 2 * math.pi)
        self.phase_z = float(rng.random() * 2 * math.pi)
        self.t = 0.0

    def feed(self, pcm: NDArray[Any], sr: int) -> List[Dict[str, float]]:
        x = _to_float32_mono(pcm)
        if x.size == 0: return []
        x = _resample_linear(x, sr, SR) if sr != SR else x

        self.carry = np.concatenate([self.carry, x]) if self.carry.size else x
        out: List[Dict[str, float]] = []

        while self.carry.size >= HOP:
            hop = self.carry[:HOP]
            self.carry = self.carry[HOP:]
            self.samples.extend(hop.tolist())
            
            if len(self.samples) < FRAME:
                self.t += HOP_MS / 1000.0
                continue

            frame = np.fromiter(islice(self.samples, len(self.samples) - FRAME, len(self.samples)), dtype=np.float32, count=FRAME)
            db = _rms_dbfs(frame)

            if db >= VAD_DB_ON:
                self.vad_above += 1
                self.vad_below = 0
                if not self.vad_on and self.vad_above >= ATTACK_FR: self.vad_on = True
            elif db <= VAD_DB_OFF:
                self.vad_below += 1
                self.vad_above = 0
                if self.vad_on and self.vad_below >= RELEASE_FR: self.vad_on = False

            if self.vad_on:
                self.sway_up = min(SWAY_ATTACK_FR, self.sway_up + 1)
                self.sway_down = 0
            else:
                self.sway_down = min(SWAY_RELEASE_FR, self.sway_down + 1)
                self.sway_up = 0

            up = self.sway_up / SWAY_ATTACK_FR
            down = 1.0 - (self.sway_down / SWAY_RELEASE_FR)
            target = up if self.vad_on else down
            
            self.sway_env += ENV_FOLLOW_GAIN * (target - self.sway_env)
            self.sway_env = max(0.0, min(1.0, self.sway_env))

            loud = _loudness_gain(db) * SWAY_MASTER
            env = self.sway_env
            self.t += HOP_MS / 1000.0

            pitch = math.radians(SWAY_A_PITCH_DEG) * loud * env * math.sin(2 * math.pi * SWAY_F_PITCH * self.t + self.phase_pitch)
            yaw = math.radians(SWAY_A_YAW_DEG) * loud * env * math.sin(2 * math.pi * SWAY_F_YAW * self.t + self.phase_yaw)
            roll = math.radians(SWAY_A_ROLL_DEG) * loud * env * math.sin(2 * math.pi * SWAY_F_ROLL * self.t + self.phase_roll)
            x_mm = SWAY_A_X_MM * loud * env * math.sin(2 * math.pi * SWAY_F_X * self.t + self.phase_x)
            y_mm = SWAY_A_Y_MM * loud * env * math.sin(2 * math.pi * SWAY_F_Y * self.t + self.phase_y)
            z_mm = SWAY_A_Z_MM * loud * env * math.sin(2 * math.pi * SWAY_F_Z * self.t + self.phase_z)

            out.append({
                "pitch_rad": pitch, "yaw_rad": yaw, "roll_rad": roll,
                "x_mm": x_mm, "y_mm": y_mm, "z_mm": z_mm,
            })
        return out

def play_audio_thread(stream, pcm_data):
    """Play the synthesized audio byte sequence to the speaker."""
    stream.write(pcm_data)

def _execute_tts_movement(reachy, client, text: str, voice: str, model: str, speaker: Optional[str]):
    neutral_head_pose = create_head_pose(0, 0, 0, 0, 0, 0, degrees=True)
    
    print("Zeroing position...")
    reachy.goto_target(head=neutral_head_pose, antennas=[0.0, 0.0], duration=1.0, body_yaw=0.0)
    time.sleep(1.0)
    
    print(f"Generating OpenAI TTS for voice: {voice}...")
    audio_response = client.audio.speech.create(
        model=model,
        voice=voice,
        input=text,
        response_format="pcm"
    )

    # Decode and buffer full audio 
    # (OpenAI TTS-1 PCM streams natively at 24kHz, 16bit, mono)
    OPENAI_SR = 24000
    pcm_bytes = b"".join([chunk for chunk in audio_response.iter_bytes(chunk_size=4096)])
    pcm_array = np.frombuffer(pcm_bytes, dtype=np.int16)

    # Initialize PyAudio
    p = pyaudio.PyAudio()

    device_index = None
    if speaker:
        for i in range(p.get_device_count()):
            try:
                info = p.get_device_info_by_index(i)
                if info.get("maxOutputChannels", 0) > 0 and speaker.lower() in info.get("name", "").lower():
                    device_index = i
                    break
            except Exception:
                pass
                
        if device_index is not None:
            print(f"Playing audio through speaker: {p.get_device_info_by_index(device_index)['name']}")
        else:
            print(f"Warning: Could not find a speaker matching '{speaker}'. Falling back to system default.", file=sys.stderr)

    stream_kwargs = {
        "format": pyaudio.paInt16,
        "channels": 1,
        "rate": OPENAI_SR,
        "output": True
    }
    if device_index is not None:
        stream_kwargs["output_device_index"] = device_index

    stream = p.open(**stream_kwargs)

    # Start audio background thread while the main thread updates robotic movements
    playback_thr = threading.Thread(target=play_audio_thread, args=(stream, pcm_bytes))
    playback_thr.start()

    # Reachy movement control loop
    sway = SwayRollRT()
    
    # 50ms chunks aligned exactly with the hop interval (50ms @ 24kHz = 1200 frames)
    frames_per_hop = int(OPENAI_SR * (HOP_MS / 1000.0)) 
    
    print(f"Speaking: '{text.strip()}'")
    for i in range(0, len(pcm_array), frames_per_hop):
        loop_start = time.time()
        
        chunk = pcm_array[i : i + frames_per_hop]
        results = sway.feed(chunk, OPENAI_SR)
        
        if results:
            r = results[-1]  # Take latest smoothed interpolation interval
            
            # Format movement offsets exactly simulating reachy_mini_conversation_app secondary poses
            secondary_head_pose = create_head_pose(
                x=r["x_mm"] / 1000.0, 
                y=r["y_mm"] / 1000.0, 
                z=r["z_mm"] / 1000.0,
                roll=r["roll_rad"],
                pitch=r["pitch_rad"],
                yaw=r["yaw_rad"],
                degrees=False, mm=False
            )
            
            # Merge with neutral head position and fire update
            combined_head = compose_world_offset(neutral_head_pose, secondary_head_pose)
            reachy.set_target(head=combined_head, antennas=[0.0, 0.0], body_yaw=0.0)
        
        # Compensate loop sleep interval (aiming to match Hop precisely)
        elapsed = time.time() - loop_start
        sleep_time = max(0.0, (HOP_MS / 1000.0) - elapsed)
        time.sleep(sleep_time)

    # Cleanup safely
    playback_thr.join()
    stream.stop_stream()
    stream.close()
    p.terminate()

    print("Returning to neutral...")
    reachy.goto_target(head=neutral_head_pose, antennas=[0.0, 0.0], duration=1.0, body_yaw=0.0)

# =========================================================================
# 4. HTTP SERVER GLOBALS & FASTAPI APP
# =========================================================================

app = FastAPI(title="Reachy TTS HTTP Server")

_GLOBAL_REACHY = None
_GLOBAL_OPENAI = None
_GLOBAL_SPEAKER = None
_TTS_LOCK = threading.Lock()

class TTSRequest(BaseModel):
    text: str
    voice: Optional[str] = "alloy"
    model: Optional[str] = "tts-1"
    speaker: Optional[str] = None

@app.post("/tts")
def tts_endpoint(req: TTSRequest):
    if not _GLOBAL_REACHY or not _GLOBAL_OPENAI:
        raise HTTPException(status_code=503, detail="TTS service is not fully initialized.")
        
    with _TTS_LOCK:
        try:
            target_speaker = req.speaker if req.speaker else _GLOBAL_SPEAKER
            _execute_tts_movement(
                _GLOBAL_REACHY, 
                _GLOBAL_OPENAI, 
                req.text, 
                req.voice, 
                req.model, 
                target_speaker
            )
            return {"status": "success", "message": "TTS completed."}
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

def main():
    global _GLOBAL_REACHY, _GLOBAL_OPENAI, _GLOBAL_SPEAKER
    
    parser = argparse.ArgumentParser(description="Reachy TTS CLI Tool")
    parser.add_argument("text", type=str, nargs="?", help="Text for Reachy to say (ignored if --http is used)")
    parser.add_argument("--voice", type=str, default="alloy", help="OpenAI voice (alloy, echo, fable, onyx, nova, shimmer) (default: alloy)")
    parser.add_argument("--model", type=str, default="tts-1", help="OpenAI TTS model (default: tts-1)")
    parser.add_argument("--api-key", type=str, help="OpenAI API Key (fallback to OPENAI_API_KEY env var)")
    parser.add_argument("--speaker", type=str, default="reSpeaker XVF3800", help="Target speaker name (default: reSpeaker XVF3800)")
    parser.add_argument("--http", action="store_true", help="Start an HTTP server instead of running directly")
    parser.add_argument("--port", type=int, default=8000, help="Port for the HTTP server (default: 8000)")
    args = parser.parse_args()

    api_key = args.api_key or os.environ.get("OPENAI_API_KEY")
    if not api_key:
        print("Error: OpenAI API key must be provided via --api-key argument or OPENAI_API_KEY environment variable.", file=sys.stderr)
        sys.exit(1)
        
    client = OpenAI(api_key=api_key)

    try:
        reachy = ReachyMini(media_backend="default")
        neutral_head_pose = create_head_pose(0, 0, 0, 0, 0, 0, degrees=True)
        reachy.goto_target(head=neutral_head_pose, antennas=[0.0, 0.0], duration=0.5, body_yaw=0.0)
    except ConnectionError:
        print("\n‚ùå Error: Could not connect to the Reachy Mini daemon.", file=sys.stderr)
        print("Please ensure the daemon is running in the background and try again.\n", file=sys.stderr)
        sys.exit(1)

    if args.http:
        _GLOBAL_REACHY = reachy
        _GLOBAL_OPENAI = client
        _GLOBAL_SPEAKER = args.speaker
        print(f"Starting FastAPI server on port {args.port}...")
        uvicorn.run(app, host="0.0.0.0", port=args.port)
    else:
        if not args.text:
            print("Error: 'text' positional argument is required unless running in --http mode.", file=sys.stderr)
            sys.exit(1)
        _execute_tts_movement(reachy, client, args.text, args.voice, args.model, args.speaker)

if __name__ == "__main__":
    main()
